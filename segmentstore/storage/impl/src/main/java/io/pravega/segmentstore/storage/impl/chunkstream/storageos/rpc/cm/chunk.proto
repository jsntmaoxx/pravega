package io.pravega.segmentstore.storage.impl.chunkstream.storageos.rpc.cm;

option java_package = "com.emc.storageos.rpc.cm";
option java_outer_classname = "CmMessage";
option java_multiple_files = false;

// status reported by SSM
enum BlockStatus {
    // the block is accessible and good
    HEALTHY = 0;
    // the block is on a suspicious node or disk
    SUSPICIOUS = 1;
    // the block is on a maintenance node or disk
    MAINTENANCE = 2;
    // the block is not accessible
    BAD = 3;
}

// Compact structure for chunkId / zone / replicationGroup
message Uuid {
    optional fixed64 highBytes = 1;
    optional fixed64 lowBytes = 2;
}

// geo secondary zone replication status
message SecondaryPair {
    optional string secondary = 1;

    required bool replicated = 2;

    optional Uuid secondaryUuid = 3;
}

message EcCodeScheme {
    required int32 numberOfDataBlocks = 1;
    required int32 numberOfCodeBlocks = 2;
}

// recovery related status
enum LocationRecoveryStatus {
    // the block is allocated by data has not copied to it yet
    RECONSTRUCTING = 0;
    // the block is ready to be freed after some delay
    RETIRING = 1;
    // the block has bit-rot detected,
    // will go to RETIRING status after a new one is ready to replace it
    CORRUPTED = 2;
}

// there should be no overlapping ranges in ss location
// each chunk offset has at most one range info
message RangeInfo {
    // offset in chunk
    required int32 chunkOffset = 1;
    // end offset in chunk
    required int32 chunkEndOffset = 2;
    // block bin
    required string filename = 3;
    // offset on block bin
    required int64 offset = 4;
}

message SSLocation {
    optional string ssId = 1;

    optional string partitionId = 2;

    optional string filename = 3;

    optional int64 offset = 4;

    required BlockStatus status = 5;

    // sequence number of status reported by SSM
    required int64 statusSn = 6;

    optional LocationRecoveryStatus recoveryStatus = 7;

    repeated RangeInfo ranges = 8;

    optional int64 tag = 9;

    optional Uuid ssIdUuid = 10;

    optional Uuid partitionIdUuid = 11;
}

message NFSLocation {
    required string deviceId = 1;

    required string filename = 2;

    required int64 offset = 3;
}

// location for object based device
message OBLocation {
    required string deviceId = 1;

    required string objectId = 2;
}

enum LocationType {
    STORAGE_SERVER = 0;
    NFS = 1;
    OBJECT_BACKEND = 2;

    SYSTEM_UNDER_TRANSFORMATION = 10;
}

message SystemUnderTransformationLocation {
    required string transformationId = 1;
    required string chunkId = 2;
}

message SegmentInfo {
    required LocationType locationType = 1;

    optional SSLocation ssLocation = 2;

    optional NFSLocation nfsLocation = 3;

    optional OBLocation obLocation = 4;

    optional string checksum = 5;

    //chunk offset
    optional int32 offset = 6;
    //chunk end offset
    optional int32 endOffset = 7;

    // ec fragment sequence num
    optional int32 sequence = 8;

    // virtual range offset
    optional int32 virtualOffset = 9;

    // virtual range endOffset
    optional int32 virtualEndOffset = 10;

    // migrate target ss location marked only by migrate source segment
    optional SSLocation migratingSsLocation = 11;

    // migrate source ssId marked only by migrate target segment
    optional string migrateSourceSsId = 12;

    // migrate sequence marked by both migrate source and target segments
    optional int64 migrateSequence = 13;

    // time for freeing migrated target segment safely
    optional int64 migrationBlockSafeFreeTime = 14;

    optional string migrationChecksum = 15;

    optional SystemUnderTransformationLocation systemUnderTransformationLocation = 100;
}

enum EcStatus {
    NOT_STARTED = 0;
    COMPLETED = 1;
    ENCODING = 2;
    REDUNDANT = 3;
}

enum ShippingStatus {
    // Shipping success
    GEO_SHIPPING_STATUS_SUCCESS = 1;
    // Shipping failed due to timeout
    GEO_SHIPPING_STATUS_FAIL_TIMEOUT = 2;
    // Shipping failed due to remote zone write failure
    GEO_SHIPPING_STATUS_FAIL_REMOTE_WRITE_FAILURE = 3;
    // underCopying
    GEO_SHIPPING_STATUS_COPYING = 4;
    // Shipping status due to unknown, most likely no one is shipping
    GEO_SHIPPING_STATUS_UNKNOWN = 5;
}

message RangeMapWithPairChunk {
    // range info in current chunk
    required int64 startOffset = 1;
    required int64 endOffset = 2;

    // XOR geo shipping pair chunk id
    required string pairChunkId = 3;

    // XOR geo shipping range in pair chunk
    required int64 pairStartOffset = 4;
    required int64 pairEndOffset = 5;
}

message ShippingRange {
    required int64 startOffset = 1;
    required int64 endOffset = 2;
    required ShippingStatus status = 3;

    // for XOR pair geo shipping
    repeated RangeMapWithPairChunk rangePairs = 4;

    // checksum for this range data
    // this field exists in remote zone if ShippingStatus is SUCCESS
    optional int32 checksum = 5;
}

message ShippingProgress {
    required int32 version = 1;
    repeated ShippingRange ranges = 2;

    repeated string pairShippedChunkIds = 3;
    // for troubleshooting purpose
    repeated int64 pairShippedChunkGarbageBits = 4;
    repeated string pairShippingChunkIds = 5;
    repeated int64 pairShippingChunkGarbageBits = 6;
    optional string currentPairShippingChunkId = 7;
}

message GeoProgress {
    required string targetZone = 1;
    optional ShippingProgress progress = 3;
}

message Copy {
    required bool isEc = 1;

    repeated SegmentInfo segments = 2;

    optional EcStatus ecStatus = 3 [default = NOT_STARTED];

    optional EcCodeScheme ecCodeScheme = 4;

    // # of ec coding retries on this copy
    optional int32 ecRetryCount = 5;

    // if padding 0 until chunk capacity
    optional bool ecEncodePaddingToCapacity = 6;

    // how many bytes each block occupied physically
    // this is optional because pre-1.2 this field is not exist,
    // but from 1.2 all the ec allocation needs this field set
    optional int32 ecBlockSize = 7;

    // true if the ec copy is created by client (BFW)
    optional bool isClientCreatedEcCopy = 8;

    // is EC copy encode completed by client (BFW),
    // i.g, client let cm update ec copy status successfully
    optional bool isEcEncodedByClient = 9 [default = false];

    //is EC copy failed in finding seal length
    optional bool isEcCopyFindSealLengthFailed = 10;

    optional bool hasRedundant = 11;
}

// for chunk state machine
enum ChunkStatus {
    ACTIVE = 0;
    SEALED = 1;
    DELETING = 2;
    GEO_DELETING = 3;
    DELETED = 4;
}

// which type of level-0 data this chunk holds
enum ChunkDataType {
    REPO = 0;
    JOURNAL = 1;
    BTREE = 2;
}

// type for geo replication
enum ChunkType {
    LOCAL = 0;
    REMOTE = 1;
    COPY = 2;
    ENCODED = 3;
    PARITY = 4;
}

// to describe chunk when it is initially created
enum RepoChunkType {
    TYPE_I = 0; // 2 normal copies + 1 EC copy, turn back to 3 normal copies if EC copy can't be allocated
    TYPE_II = 1; // single EC copy
}

// to describe the data type stored in btree chunk
enum BTreeChunkDataType {
    GENERAL = 0;
    LEAF_PAGE = 1; // btree leaf page
    INDEX_PAGE = 2; // index page, ct progress, occupancy, bloomfilter
}

enum ChunkCustomState {
    PARTIALGC_COPYFROM = 0;
    PARTIALGC_COPYTO = 1;
    PARTIALGC_NO_CANDIDATE = 2;
}

message RangeBasedChunkInfo {
    // physical range in chunk
    required int32 startOffset = 1;

    required int32 endOffset = 2;

    // chunk type of this range: COPY/ENCODED
    required ChunkType type = 3;

    // if XOR by-range encoded, partity chunk id
    optional string parityChunk = 4;

    // if shipped XOR range, encoded chunk id
    required string encodedChunk = 5;

    // target range in partityChunk/encodedChunks
    required int32 targetStartOffset = 6;
    required int32 targetEndOffset = 7;

    // between virtualOffset and endOffset the data is all 0's
    optional int32 virtualOffset = 8;
}

message ChunkInfo {
    required ChunkStatus status = 1;

    required ChunkDataType dataType = 2;

    required ChunkType type = 3;

    // replication group
    optional string repGroup = 4;

    // zone of primary, present if type is REMOTE, COPY or ENCODED
    optional string primary = 5;

    // zone of secondary, present if type is LOCAL or REMOTE
    repeated SecondaryPair secondaries = 6;

    // parity chunk id, present if type is ENCODED
    optional string parityChunk = 7;

    // list of encoded chunk ids, present if type is PARITY
    repeated string encodedChunks = 8;

    // copies of chunk data, present if type is LOCAL, COPY or PARITY;
    // if type is REMOTE or ENCODED, present only when there is cached data
    repeated Copy copies = 9;

    // indicate the capacity of chunk, for file access capacity is -1 (unlimited)
    optional int32 capacity = 10;

    optional int32 sealedLength = 11;

    // when the chunk should be automatically sealed (due to timeout)
    // only present if chunk is ACTIVE
    optional int64 autoSealTime = 12;

    // chunk sealed time, only present if chunk is sealed
    optional int64 sealedTime = 13;

    // if the chunk has been EC encoded, missing means false
    optional bool isEcEncoded = 14;

    // TODO: should there be a last access time (updated with very low frequency)
    // to guide the EC coding?

    //a flag to indicate whether should reject lease extend request
    optional bool shouldSeal = 15;

    required int64 sequenceNumber = 16;

    required int64 minNotSealedSequenceNumber = 17;

    optional string checksum = 18;

    // shadow chunk info that could replace the current one later
    optional ChunkInfo shadow = 19;

    // if the chunk is being transformed from ec back to 3 copies
    optional bool isEcRetiring = 20;

    // skip repo gc will be set when repo copy chunk is promoted to local
    optional bool skipRepoGc = 21;

    //the chunk doesn't include block-level verification like file ingestion chunk
    optional bool noBlockLevelVerification = 22;

    // last access time (updated with very low frequency)
    // TODO: shall this also be used to guide the EC coding?
    // for REMOTE chunk type this is updated by remote chunk cache lazily
    optional int64 lastAccessTime = 23;

    // client may report last known length of the chunk
    // in chunk lease extension message
    // This reduces for e.g. journal replay time
    optional int32 lastKnownLength = 24;

    // all the repo chunks should have this field set
    optional RepoChunkType repoChunkType = 25;

    // if set, file will be truncated to expected length of Copies
    // specifically used for vnest journal partial write vs. corruption checking
    optional SegmentInfo shadowCopy = 26;

    // copies of chunk data, present if type is REMOTE;
    // present only when unsealed geo replication is ongoing
    repeated Copy geoCopies = 27;

    //when geo track task should be invoke to do the final geo check
    optional uint64 geoTrackTime = 28;
    //geo write progress
    //journal chunk may have multiple progress as it should be replicated to multi zone
    repeated GeoProgress geoProgress = 29;

    //Original primary zone of the chunk; Set when a COPY promoted to LOCAL after failover
    optional string originalPrimary = 30;

    // chunk deleted time, only present if chunk is in deleted state
    optional int64 deletedTime = 31;

    // partial Gc task status
    optional ChunkCustomState customState = 32;

    // failover zone
    optional string failoverZone = 33;

    // Set true after all transactions on it are over and sealed.
    // If not set or false, wait 78 hours after sealed for GC verification.
    optional bool isGCReady = 34;

    repeated string dtTypes = 35;

    // for 2MB write block alignment
    optional int32 alignmentSize = 36;

    // xor geo shipped copies, will be removed after encoded with
    // either COPY or PARITY chunks
    repeated Copy encodedCopies = 37;

    // checksum for xor geo shipped copies, i.e. encodedCopies
    optional int32 checksumForEncodedCopies = 38;

    // this flag is set after chunk shipping completed
    optional bool usingXorGeoShipping = 39;

    // shadow blocks need to be freed
    optional bool freeShadowBlocks = 40;

    // for COPY/ENCODED chunk
    repeated RangeBasedChunkInfo chunkInfoByRanges = 50;

    // list of xor-shipped chunks to be encoded against it
    repeated string pendingEncodeChunks = 51;

    optional bool sealingInProgress = 52;

    optional bool everTryRemoveTypeII = 53;

    optional int64 createTime = 54;

    optional bool isGcVerificationNeeded = 55;

    optional bool isEcRedundant = 56;

    optional Uuid repGroupUuid = 57;

    optional Uuid primaryUuid = 58;

    optional Uuid parityChunkUuid = 59;

    //Only used to mark if pendingForFreeSpaceStats stats is added for chunk
    optional bool cmPendingForFreeSpaceStats = 60;

    optional int64 partialSRCopiedData = 61;

    optional BTreeChunkDataType bTreeChunkDataType = 62 [default = GENERAL];

    //a flag to indicate whether should geo replicate for bootstrap
    optional bool isPageTable = 63;
    optional bool shouldShip = 64;

    // If journal chunk is active, DTInit find valid chunk length and replay the content, persistent valid length
    // in this filed, the journal seal length should larger than it.
    optional int32 maxKnownJournalReplayLength = 65;

    optional string epoch = 66;

    // for big hummer
    optional int32 maxWriteBlockSize = 67;

    optional StoragePolicy storagePolicy = 68;

    // if has generated precheck task
    optional bool generatedSRPrecheckTask = 69;

    optional Source source = 70;

    // if has ever force checked reclaimable/canSkipGCVerification regardless RepoReferenceCollectorStatus
    optional bool everForceCheckedReclaimable = 71;

    // Total amount of data of free full virtual segments for ECed repo chunks
    optional int32 dataRepoFree = 72;

    optional int32 indexGranularity = 73;

    optional string originalKey = 74;

    optional int64 tag = 75;
}

message StoragePolicy {
    optional string name = 1;//should be unique
    optional EcCodeScheme ecScheme = 2;
    optional PlacementSafeCheckLevel placementSafeCheckLevel = 3;
}

//use by CM to check whether a chunk has safe segments placement
enum PlacementSafeCheckLevel {
    FD = 0;
    NODE = 1;
}

enum Source {
    USER_INJECTED = 0;
    REPLICATED = 1;
}

// messages between client and chunk manager

enum ChunkOperationStatus {
    // the common status
    SUCCESS = 0;

    ERROR_INTERNAL = 1;
    ERROR_INVALID_ARGUMENT = 2;
    ERROR_NO_SPACE = 3;
    ERROR_NO_SUCH_CHUNK = 4;
    // operation error due to chunk should be sealed, e.g.,
    // extend lease op for timeout/auto seal failed as cm detects upgrade/recovery is needed for the chunk
    ERROR_SHOULD_SEAL = 5;
    ERROR_NO_STORAGE_DEVICE_FOUND = 6;
    ERROR_NO_ZONE_FOUND = 7;
    ERROR_ALREADY_SEALED = 8;
    ERROR_ALREADY_GEO_REPLICATED = 9;
    ERROR_RG_NOT_FOUND = 10;
    ERROR_ALLOCATE_BLOCK_FAILED = 11;
    ERROR_UNSEALED_TOO_MUCH_COPIES_FAILED = 12;
    IN_PROGRESS = 13;
    ERROR_ALREADY_DELETING = 14;
    ERROR_INVALID_EC_SCHEME = 15;
    ERROR_ALREADY_GC_READY = 16;
    ERROR_ALREADY_SEALING = 17;
    ERROR_NOT_CANDIDATE = 18;
    CHUNK_NOT_EXIST = 19;
}

// create LOCAL or COPY chunk
message ChunkCreateRequest {
    extensions 100 to max;

    required string chunkId = 1;

    required ChunkDataType dataType = 2;

    // could be LOCAL, REMOTE or COPY
    required ChunkType type = 3;

    // node id of the writer, CM will pick up one SS on the same node for the writer
    // not required for REMOTE chunk
    optional string writerNodeId = 4;

    // zone of primary, present if type is COPY
    optional string primary = 5;

    // writer id, as there could be multiple writers on the same node
    optional string writerId = 6;

    // simply use SSLocation though it has some redundant fields
    repeated SSLocation hints = 7;

    // if the chunk is for file access (thus size is unlimited)
    optional bool unlimitedSize = 8 [default = false];

    // replication group
    optional string repGroup = 9;

    // file system device Id is used for file access mode where chunk needs to be created on a specific device
    // so this needs to be passed from client to CM to SSM
    optional string fsDeviceId = 10;

    optional string filePath = 11;

    optional int64 fileOffset = 12;

    optional int32 chunkSize = 13;

    //negative hints for CM to create chunks
    repeated SSLocation negativeHints = 14;

    optional RepoChunkType repoChunkType = 15;

    optional bool skipChunkSequenceNumber = 16;

    optional ChunkCustomState customState = 17;

    //DT types stored in this chunk (for btree only)
    repeated string dtTypes = 18;

    optional int32 alignmentSize = 19;

    optional BTreeChunkDataType bTreeChunkDataType = 20 [default = GENERAL];

    optional bool isPageTable = 21;

    optional int32 maxWriteBlockSize = 22;

    optional StoragePolicy storagePolicy = 23;

    optional Source source = 24;

    // for chunk server
    optional int32 indexGranularity = 25;
    optional int32 customChunkSize = 26;
    optional EcCodeScheme ecCodeScheme = 27;
    optional bool skipRepoGC = 28;
    optional string originalKey = 29;
    optional int64 tag = 30;
}

message ReplaceBlockRequest {

    required string chunkId = 1;

    required ChunkDataType dataType = 2;

    required SegmentInfo segmentInfo = 3;

    // node id of the writer, CM will pick up one SS on the same node for the writer
    optional string writerNodeId = 4;

    // writer id, as there could be multiple writers on the same node
    optional string writerId = 5;

}

message ReplaceBlockResponse {
    required ChunkOperationStatus status = 1 [default = SUCCESS];

    optional ChunkInfo chunkInfo = 2;
}

message IngestSystemUnderTransformationRepoChunkRequest {
    extend ChunkCreateRequest {
        optional IngestSystemUnderTransformationRepoChunkRequest ingestSystemUnderTransformationRepoChunkRequest = 101;
    }
    required string transformationId = 1;
}

message ChunkCreateResponse {
    required ChunkOperationStatus status = 1 [default = SUCCESS];

    optional ChunkInfo chunkInfo = 2;
}

message ChunkDeleteRequest {
    required string chunkId = 1;
    //force flag for delete chunk request.
    //if the flag is set, on-going unsealed geo replication will be canceled
    //geo delete will start.
    optional bool forceFlag = 2;
}

message ChunkDeleteResponse {
    required ChunkOperationStatus status = 1 [default = SUCCESS];
}

message ChunkObjectDeleteRequest {
    required string chunkId = 1;
    optional int32 freeBlockDelaySeconds = 2;
}

message ChunkObjectDeleteResponse {
    required ChunkOperationStatus status = 1 [default = SUCCESS];
}

message ChunkSealRequest {
    required string chunkId = 1;

    required int32 length = 2;

    // track caller that issue the seal request
    // deprecated, moved to FileOperationPayload
    optional string client = 3;

    // indicate if client (BFW) will do EC or not
    optional bool isEcInClient = 4;

    optional bool checkTask = 5 [default = false];
}

message ChunkSealResponse {
    required ChunkOperationStatus status = 1 [default = SUCCESS];

    // if the chunk is successfully sealed, bring back the new ChunkInfo
    optional ChunkInfo chunkInfo = 2;
}

// issued from client to notify encode is done
message ClientEcEncodeCompletionRequest {
    required string chunkId = 1;

    // updated segment info
    repeated SegmentInfo segments = 2;

    // seal length
    required int32 sealLength = 3;

    // copy to mark for ec completion
    required Copy ecCopy = 4;
}

message ClientEcEncodeCompletionResponse {
    required ChunkOperationStatus status = 1 [default = SUCCESS];

    optional ChunkInfo chunkInfo = 2;
}

message ChunkQueryRequest {
    required string chunkId = 1;

    // if the chunk info not present is one of the expected valid case
    // (e.g., during geo replay)
    optional bool couldMiss = 2;
    // is this query for read remote, chunkInfo is present but chunk is in GEO_DELETING state,
    // chunk needs to be read from primary for xor decode
    optional bool isReadForDecode = 3;

    optional bool doBroadcast = 4;

    optional string repGroup = 5;
    // DELETED chunk needs to be read from primary when check for spillover chunk
    optional bool isReadForSpillover = 6;
}

message ChunkQueryResponse {
    required ChunkOperationStatus status = 1 [default = SUCCESS];

    optional ChunkInfo chunkInfo = 2;
}

message ChunkSealLeaseExtendRequest {
    required string chunkId = 1;
    optional int32 lastKnownLength = 2;
}

message ChunkSealLeaseExtendResponse {
    required ChunkOperationStatus status = 1;

    // if the chunk is already sealed, give the sealed length
    optional int32 sealedLength = 2;
}

message ChunkUpdateRequest {
    required string chunkId = 1;

    required ChunkInfo chunkInfo = 2;
}