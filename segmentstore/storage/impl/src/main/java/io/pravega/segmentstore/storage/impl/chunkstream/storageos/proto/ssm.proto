package io.pravega.segmentstore.storage.impl.chunkstream.storageos.rpc.ssm;

option java_package = "io.pravega.segmentstore.storage.impl.chunkstream.storageos.rpc.ssm";
option java_outer_classname = "SsmMessage";
option java_multiple_files = false;

enum BlockOperationStatus {
    // the common status
    SUCCESS = 0;

    ERROR_INTERNAL = 1;
    ERROR_INVALID_ARGUMENT = 2;
    ERROR_NO_SPACE = 3;
    ERROR_NOT_REFERENCED = 4;
    ERROR_ALLOCATE_FAIL = 5;

    ERROR_MIGRATION_CHUNK_DELETING_OR_DELETED = 6;
    ERROR_MIGRATION_CHUNK_LOCAL_ACTIVE = 7;
    ERROR_MIGRATION_CHUNK_EC_RETIRING = 8;
    ERROR_MIGRATION_CHUNK_EC_NOT_COMPLETE = 9;
    ERROR_MIGRATION_SEGMENT_BAD = 10;
    ERROR_MIGRATION_CHUNK_REMOTE_ACTIVE = 11; // not local & active
    ERROR_MIGRATION_SOURCE_SEGMENT_GEO_CACHE = 12;
    ERROR_MIGRATION_CHUNK_GEO_REPLICATING = 13;
    ERROR_MIGRATION_CHUNK_XOR_ENCODING = 14;
    ERROR_MIGRATION_CHUNK_XOR_DECODING = 15;
    ERROR_MIGRATION_CHUNK_GEO_DELETING = 16;

    ERROR_MIGRATION_CHUNK_UNDER_TRANSFORMATION = 17;
    ERROR_INVALID_CHUNK_STATUS = 18;
    ERROR_MIGRATION_CHUNK_NOT_FOUND = 19;

    ERROR_MIGRATION_ALLOCATE_TIMEOUT = 20;
    ERROR_MIGRATION_SOURCE_SEGMENT_HAS_RECOVERY_STATUS = 21;
    ERROR_MIGRATION_SOURCE_SEGMENT_NOT_VALID = 22;
    ERROR_MIGRATION_TARGET_SEGMENT_NOT_VALID = 23;
    ERROR_MIGRATION_SOURCE_SEGMENT_NOT_FOUND = 24;
    ERROR_MIGRATION_TARGET_SEGMENT_NOT_FOUND = 25;
    ERROR_MIGRATION_TASK_NOT_TRACKED = 26;
    ERROR_MIGRATION_UPDATE_CHUNKINFO_FAIL = 27;
    ERROR_MIGRATION_CHECKSUM_UNAVAILABLE = 28;
    ERROR_MIGRATION_TARGET_SEGMENT_BLACKLISTED = 29;
}

enum ChunkAllocateType {
    UNKNOWN_CHUNK = 0;
    REPO_CHUNK = 1;
    BTREE_CHUNK = 2;
    JOURNAL_CHUNK = 3;
    REALLOCATE_CHUNK = 4;
}

enum AllocateProcessType {
    UNKNOWN_PROCESS = 0;
    BLOBSVC = 1;
    CM = 2;
    SR = 3;
    SSM = 4;
    RM = 5;
    RESOURCE = 6;
    DATAHEADSVC = 7;
    VNEST = 8;
    DTQUERY = 9;
    OBJCONTROLSVC = 10;
    GEORECEIVER = 11;
    EVENT = 12;
    METERING = 13;
    TRANSFORM = 14;
    SSM_REALLOCATE = 15;
}

message BlockSegment {
    required string blockBinId = 1;
    required int64 offset = 2;
    required int64 size = 3;
    optional int64 tag = 4;
}

message BlockAllocateRequest {
    required string ssId = 1;

    required string chunkId = 2;

    // size(in bytes) of the block to allocate
    optional int64 size = 3;

    // pass partition id as optional hint to allocate on the same disk
    optional string hint = 4;

    // a list of partition ids to avoid allocate on
    repeated string negativeHints = 5;

    optional string writerId = 6;

    // opaque info for CM to locate the block info
    // if the block info could be stored other than chunk info
    optional bytes opaque = 7;

    // Hints for SSM to allocate a series of discrete blocks
    repeated int64 sizes = 8;

    optional ChunkAllocateType chunkAllocateType = 9;

    optional AllocateProcessType allocateProcessType = 10;
}

message BlockAllocateResponse {
    required BlockOperationStatus status = 1 [default = SUCCESS];

    // redundant with that in request,
    // to make the processing of response and debug easier
    optional string ssId = 2;

    optional string partitionId = 3;

    optional string blockBinId = 4;

    optional int64 offset = 5;

    repeated BlockSegment segments = 6;

    optional int64 tag = 7;
}