package io.pravega.segmentstore.storage.impl.chunkstream.storageos.rpc.disk;

option java_package = "io.pravega.segmentstore.storage.impl.chunkstream.storageos.rpc.disk";
option java_outer_classname = "StorageServerMessages";
option java_multiple_files = false;

message Request {
    required int64 version = 1;
    required bytes messageCheckSum = 2; //checksum of the message

    optional bytes context = 3; // if included will be returned in the response
    optional string requestId = 4; // if included will be returned in response
    optional string origin = 5; // client side marker to track origin of request on server
    optional uint64 timeout = 6;
    optional uint32 policyId = 7 [default = 0]; // defines resources allocation and execution algorithm
    optional int64 createTime = 8;

    extensions 1000 to max; // 19000 through 19999 are reserved
}

/*
 * Base response message
 * All responses are wrapped inside of this message
 *
 */
message Response {
    enum Status {
        SUCCESS = 1;
        ERROR = 2;
    }

    // used for dealing with changes in protocol messages
    required int64 version = 1;

    // Used generically for success/failure of request. Additional information
    // may be provided by the errorMessage field and child response message may have additional
    // states/messages
    required Response.Status status = 2;

    required bytes messageCheckSum = 3;

    // Used generically
    optional string errorMessage = 4;

    // If included will be returned in the response
    optional bytes context = 5;
    optional string requestId = 6;

    optional int32 errorCode = 7;
    optional int64 createTime = 8;
    optional int64 requestTime = 9;

    extensions 1000 to max; // 19000 through 19999 are reserved
}

// New types of requests are added to the Request
extend Request {
    optional WriteRequest writeRequest = 1000;
    optional ReadRequest readRequest = 1001;
    optional VerifyDataRequest verifyRequest = 1002;
    optional ConfigurationRequest configRequest = 1003;
    optional StatusRequest statusRequest = 1004;
    optional CopyFromRequest copyFromRequest = 1005;
    optional SyncBlockBinRequest syncBlockBinRequest = 1006;
    optional EventRequest eventRequest = 1007;
    optional ConnectionPoolRequest connectionPoolRequest = 1008;
    optional MgmtRequest mgmtRequest = 1009;
    optional PingRequest pingRequest = 1010;
    optional DeleteRequest deleteRequest = 1011;

    optional ReadAheadRequest readAheadRequest = 1012;
    // Tech Refresh Related Requests
    optional QueryDataCopyRequest queryDataCopyRequest = 1013;
    optional TriggerDataCopyRequest triggerDataCopyRequest = 1014;
    optional InterruptDataCopyRequest interruptDataCopyRequest = 1015;
    optional StopDataCopyRequest stopDataCopyRequest = 1016;


}

// New types of responses are added to the Response
extend Response {
    optional WriteResponse writeResponse = 1000;
    optional ReadResponse readResponse = 1001;
    optional VerifyDataResponse verifyResponse = 1002;
    optional ConfigurationResponse configResponse = 1003;
    optional StatusResponse statusResponse = 1004;
    optional CopyFromResponse copyFromResponse = 1005;
    optional SyncBlockBinResponse syncBlockBinResponse = 1006;
    optional ConnectionPoolResponse connectionPoolResponse = 1007;
    optional MgmtResponse mgmtResponse = 1008;
    optional PingResponse pingResponse = 1009;
    optional DeleteResponse deleteResponse = 1010;
    optional ReadAheadResponse readAheadResponse = 1011;

    // Tech Refresh Related Response
    optional QueryDataCopyResponse queryDataCopyResponse = 1012;
    optional TriggerDataCopyResponse triggerDataCopyResponse = 1013;
    optional InterruptDataCopyResponse interruptDataCopyResponse = 1014;
    optional StopDataCopyResponse stopDataCopyResponse = 1015;
}

message RequestMetadata {
    optional uint32 chunkSize = 1;
    optional uint64 chunkOffset = 2;
    optional bool shouldCache = 3;
}

/*
 * Calls datasync on the specified file
 * Used when WriteRequest sets syncOnWrite = false as a final step
 * to ensure data was written fully to disk
 */
message SyncBlockBinRequest {
    required string partitionUuid = 1;
    required string fileName = 2;

    optional RequestMetadata metadata = 3;
    optional int64 startingOffset = 4;
    optional int64 dataLength = 5;
}

// used to help identify response of SyncBlockBinRequest
message SyncBlockBinResponse {
    required string serverStartTime = 1;
}

/*
 * Writes a block of data to the specified location
 */
message WriteRequest {
    required string partitionUuid = 1;
    required string fileName = 2;
    required int64 startingOffset = 3;
    required int64 dataLength = 4;
    optional bool syncOnWrite = 5 [default = true];

    // if present will compare against checksum calculated by server
    // if checksums do not match an error will be returned
    // calculated checksum in response will always be returned regardless
    optional bytes dataCheckSum = 6;

    // if present and true, storage server will not write data to the disk
    // this flag is only used for testing storage server
    optional bool skipWrite = 7 [default = false];

    optional RequestMetadata metadata = 8;

    optional int32 fanoutNumber = 9;
    optional int64 payloadOffset = 10;
    optional int64 writeLength = 11;
}

message WriteResponse {

    //Hash of the data written so the client can
    //verify if the data was correct or not and take
    //the appropriate action.
    optional bytes dataCheckSum = 1;

    // if syncOnWrite = false, returns start time of
    // server to know if a reset happened between the call
    // to write and the call to sync to disk
    optional string serverStartTime = 2;
}

/*
 * Read the requested block
 */
message ReadRequest {
    required string partitionUuid = 1;
    required string fileName = 2;
    required int64 startingOffset = 3;
    required int64 dataLength = 4;

    optional RequestMetadata metadata = 5;
}

message ReadResponse {
    required int64 dataLength = 1;
}

/*
 * Calls data delete on the specified file
 */
message DeleteRequest {
    required string partitionUuid = 1;
    required string fileName = 2;
    required int64 startingOffset = 3;
    required int64 dataLength = 4;

    optional RequestMetadata metadata = 5;
}
// used to help identify response of DeleteRequest
message DeleteResponse {
    required string serverStartTime = 1;
}

// readAhead request used for new BFW
message ReadAheadRequest {
    required string partitionUuid = 1;
    required string fileName = 2;
    required int64 startingOffset = 3;
    required int64 dataLength = 4;

    optional RequestMetadata metadata = 5;
}

message ReadAheadResponse {
    required bool success = 1;
}
// readAhead response used for new BFW

/* calculates a checksum based on the data provided and
 * returns it in the response
 */
message VerifyDataRequest {
    required string partitionUuid = 1;
    required string fileName = 2;
    required int64 startingOffset = 3;
    required int64 dataLength = 4;
}

message VerifyDataResponse {
    required bytes dataCheckSum = 1; //Hash of the data verified so the client can
    //verify if the data was correct or not and take
    //the appropriate action.
}

// pull request from another storage server
message CopyFromRequest {
    // server to connect to - host:port
    required string sourceServerName = 1;
    required string soucePartitionUuid = 2;
    required string sourceFileName = 3;
    required string sourceStartingOffset = 4;
    required string partitionUuid = 5;
    required string fileName = 6;
    required string startingOffset = 7;
    required string dataLength = 8;
}

message CopyFromResponse {
    optional bytes dataCheckSum = 1;
}

message SetConfigurationRequest {

    // change id
    optional string storageServerId = 1;
    // change default blockbin byte size
    optional int64 defaultBlockBinSizeBytes = 2;
}

message SetConfigurationResponse {
    required Configuration configuration = 1;
}

message ConfigurationRequest {
    repeated ConfigurationRequestForSSD ssdConfigurationRequest = 1;
    optional int32 level = 2;
    optional int32 highestLevel = 3;
}

message ConfigurationRequestForSSD {
    required string ssdId = 1;
    required bool requestInvalidatedCache = 2;
    optional Locations notifiedLocations = 3;
    optional Location token = 4;
}

message ConfigurationResponse {
    required Configuration configuration = 1;
}

message Configuration {
    required string storageServerId = 1;
    required bool syslogEnabled = 2;
    required string syslogFlags = 3;
    required int64 defaultBlockBinSizeBytes = 4;
    required Status status = 5;
    repeated PartitionInfo partition = 6;
}

message Location {
    required string partitionId = 1;
    required string blockBinId = 2;
    required int64 offset = 3;
    required int64 size = 4;
}

message Locations {
    repeated Location location = 1;
}

message PartitionInfo {

    enum PartitionState {
        UNKNOWN = 0;
        ONLINE = 1;
        OFFLINE = 2;
        ERROR = 3; // Partition may be online but in an degraded state or starting to fail
        REMOVED = 4;
        MAINTENANCE = 5;
    }

    message BlockBinInfo {
        enum BlockBinState {
            ONLINE = 1;
            ERROR = 2;
        }
        required string id = 1;
        required int64 size = 2;
        required BlockBinState state = 3;
        optional string errorMessage = 4;
    }

    required string uuid = 1;
    required string path = 2;
    required PartitionState state = 3;
    optional string errorMessage = 4;

    required int64 sizeBytes = 5;
    required int64 availableBytes = 6;

    repeated BlockBinInfo blockBinInfo = 7;
    optional string serialNumber = 8;
    optional string slot = 9;
    optional string device = 10;
    optional bool isSSD = 11;
    optional Locations locations = 12;
}

message StatusRequest {
}

message StatusResponse {
    required string storageServerId = 1;
    required Status status = 2;
    required int64 changeId = 3;
}
message Status {
    required string serverStartTime = 1;
    required int64 requestCount = 2; // number of requests
    required int64 requestErrorCount = 3; // number of requests that encountered an error
    required int64 partitionCount = 4; //the number of partitions currently active.
    required int64 partitionError = 5; //The number of partitions currently in an error state.
}

message PingRequest {
}

message IOStats {
    required uint64 averageReadRequestTime = 1; // average time of read requests execution, mcs
    required uint64 averageWriteRequestTime = 2; // average time of write requests execution, mcs
    required uint64 estimatedReadRequestTime = 3; // estimated time for future read requests execution, mcs
    required uint64 estimatedWriteRequestTime = 4; // estimated time for future write requests execution, mcs
    required uint64 readOperations = 5; // number of pread sys calls
    required uint64 writeOperations = 6; // number of pwrite sys calls
    required uint64 averageReadTime = 7; // average time spent for data reading (pread), mcs
    required uint64 averageWriteTime = 8; // average time spent for data writing (pwrite), mcs
}

message PartitionStats {
    required string uuid = 1;
    required IOStats stats = 2;
}

message PingResponse {
    repeated PartitionStats partitionStats = 1;
}

//
// If we decide to do outbound events from the storage server
// Would have to decide how we want to register to receive events
//


message Event {
    enum Severity {
        INFORMATIONAL = 1;
        CLEAR = 2;
        WARNING = 3;
        MINOR = 4;
        MAJOR = 5;
        CRITICAL = 6;
    }

    required int64 eventId = 1;
    required int64 eventMessage = 2;
    required string dateTime = 3;
    required Severity severity = 4;
}

message EventRequest {
    required string storageServerId = 1;
    required Event event = 2;
}

message ConnectionPoolRequest {
    required string poolId = 1;
}

message ConnectionPoolResponse {
}

message Entry {
    required string key = 1;
    required string value = 2;
}

message MgmtRequest {
    required string cmd = 1;
    repeated Entry parameters = 2;
}

message MgmtResponse {
    repeated Entry results = 1;
}

message DataCopyLocation {
    // Target SS Node Id
    optional string ssId = 1;
    // Target SS Node Ip
    optional string ssIp = 2;
    // Target SS port for data copy request
    optional int32 port = 3;
    // Target location on target node for data copy requests
    optional Location location = 4;
}

// Request to query data copy task status on storage server
// When receive this request, SS should return all tasks and its status for the specified group in the response,
//     if the group specified not exist, return empty result.
message QueryDataCopyRequest {
    // Group must be specified, should be set with SS table level,
    //    if level < 0 then SS should return all level tasks on this SS,
    //    otherwise return task status in specified task group
    optional int32 group = 1;
}

message QueryDataCopyResponse {
    repeated DataCopyTask taskStatus = 1;
}


message DataCopyTask {
    enum CopyStatus {
        // This task is still pending in queue
        PLANNED = 1;
        // This task has start sending data from source storage server
        IN_PROGRESS = 2;
        // Target node can not be reached from source node
        TARGET_NODE_UNAVAILABLE = 3;
        // Target partition is offline or could not write
        TARGET_PARTITION_UNAVAILABLE = 4;
        // Source partition is offline or could not read
        SOURCE_PARTITION_UNAVAILABLE = 5;
        // This task can not start other reasons, like source/target partition id not exist, target ip and id not match, etc.
        ERROR_INTERNAL = 6;
        // This task failed checksum check when read from source node
        ERROR_CHECKSUM_MISMATCH_ON_SOURCE = 7;
        // This task failed checksum check when write to target node
        ERROR_CHECKSUM_MISMATCH_ON_TARGET = 8;
    }

    // Task Id to identify a task, task with same source should have same task id
    optional string taskId = 1;
    // Must specified to identify which SS table level this task belongs to
    optional int32 group = 2;
    // Used to identify how much bytes for this task has been copied to target node,
    // if task is IN_PROGRESS status and byteCopied == size, this means all request data has been copied to target node
    // This field should be included in query response
    // Note: There are no garantee that data are copied with data order. So if retry happened, should retry copy from the beginning.
    optional int64 bytesCopied = 4;
    // Status of this copy task
    optional CopyStatus copyStatus = 5;
    // Source location of this task
    // Task in TriggerDataCopyRequest should include this field
    // Task in QueryDataCopyResponse should include this field when task completed transmission.
    optional Location sourceLocation = 6;
    // Target location of this task
    // Task in TriggerDataCopyRequest should include this field
    // Task in QueryDataCopyResponse should include this field when task completed transmission.
    optional DataCopyLocation targetLocation = 7;
    // Checksum for this block.
    // If this field is specified, when read data from source partition and write data to target partition,
    //      SS should calculate and validate checksum.
    // Checksum should be CRC32 of the whole data block
    optional int32 checksum = 8;
}

// Request to trigger a data copy task on storage server
// When receive this request, SS should check if the task exist in task list in specified group, if not, should put it into task list for this group.
// If specified group not exist on SS (i.e. First time or restart), create this group.
// When SS return success, means all tasks specified in the request has been received by storage server.
message TriggerDataCopyRequest {
    // Only taskId, sourceLocation and targetLocation will be set in Data Copy Task
    repeated DataCopyTask task = 1;
}


message TriggerDataCopyResponse {

}

// Request to remove specified data copy request on source storage server.
// When receive this request, SS should remove specified data copy task on SS.
// If specified group not exist on SS yet (i.e. SS restarts) or task does not exist in specified group, directly return success.
// If Task is on-going, also need to terminate data transmission from source storage server side.
// When SS return success, means all tasks specified in request are terminated and removed on source storager server side.
message InterruptDataCopyRequest {
    // Must specify with SS table level, and group should be >=0 so SS search and interrupt tasks in certain level
    optional int32 group = 1;

    repeated string taskId = 2;
}

message InterruptDataCopyResponse {

}

// Request to stop and remove all data copy request on source storage server.
// When SS receives request. it should remove all data copy tasks in specified group and terminate all its connection,
//     if specified group not exist on SS yet (i.e. SS restarts), directly return success,
// If there are on-going data copy tasks, need to terminate data transmission from source storage server side.
// When SS return success, means all tasks in this group (or all if group <0) and connections are terminated from source storage server side,
//    and specified group has been removed.
message StopDataCopyRequest {
    // Must specify with SS table level, if group < 0 then stop all levels' task on SS.
    optional int32 group = 1;

}

message StopDataCopyResponse {

}




