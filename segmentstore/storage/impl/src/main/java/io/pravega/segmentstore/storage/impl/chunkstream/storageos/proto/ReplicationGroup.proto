package io.pravega.segmentstore.storage.impl.chunkstream.storageos.data.object.repgroup;
import "Zone.proto";

option java_package = "io.pravega.segmentstore.storage.impl.chunkstream.storageos.rpc.rg";
option java_outer_classname = "ReplicationGroup";
option java_multiple_files = false;

enum UpdateType {
    ADD = 1;
    REMOVE = 2;
}

/**
 * Replication group states,
 *     INTRODUCED, when a new replication group is intruded by the administrator,
 *               via the rest call.
 *     ACCEPTED, once all active zones accepted this change.  Specifically let
 *               RG1 = {A, B} and RG2 = {A, D} be the replication groups. Then
 *               the active zones are: (RG1 intersection RG2) union R2.  Since B
 *               is being removed, we don't care if it accepted since by now the
 *               administrator will pull the switch on B.
 *     REJECTED, once all active zones reject this change.  This could happen if
 *               the reconfiguration request is sent before the last configuration
 *               transitioned into STABLE
 *     UPDATING, the period where the bootstrapping and failure recovery tasks are
 *               being performed.
 *     STABLE, when all updating activities completed.
 */

enum ReconfigStateType {
    NONE = 1;
    INTRODUCED = 2;
    ACCEPTED = 4;
    UPDATING = 5;
    REJECTED = 6; // terminating state
    STABLE = 7;   //terminating state
}


message ZoneCosInfo {
    required string zoneId = 1;
    optional string vArray = 2;
    // set to true if zone is serving as a target zone for repository chunks replication.
    // this flag ensures a mapping of an RG to zone and how it functions within.
    optional bool   isTargetZone = 3 [default = false];
}

// tracks when zones were added/removed from a replication group
message ZoneCosUpdateHistory {
    required ZoneCosInfo zoneCosInfo = 1;    
    required UpdateType type = 2;
    required int64 updateTime = 3; 
}

//map zoneIdFrom to zoneIdTo (failed zone -> new zone to take over)
message ZoneMappingPair {
    required string zoneIdFrom = 1;
    required string zoneIdTo   = 2;
}

message ZoneMapping {
    repeated ZoneMappingPair zoneMapping  = 1;
}

message ZoneInfoList {
    repeated io.pravega.segmentstore.storage.impl.chunkstream.storageos.data.object.zone.ZoneInfo zoneInfo = 1;
}

message ReplicationGroupInfo {
    required string         id                  = 1;
    required string         name                = 2;
    required string         description         = 3;
    required uint64         lastStableUpdate    = 4;
    repeated ZoneCosInfo    zoneCos             = 5;
    optional string         etag                = 6;
    optional int64          creationTime        = 7;
    optional ZoneMapping    zoneMapping         = 8;
    optional ZoneInfoList   zoneInfos           = 9;
    optional bool 			allowAllNamespaces  = 10;
    optional bool 			isFullRep           = 11;
    optional bool			enableRebalancing	= 12;
    // if true, always use a specific zone as replication target, aka asymmetric replication
    optional bool			useReplicationTarget  = 13;
    repeated ZoneCosUpdateHistory zoneCosUpdateHistory = 14;
    optional bool           isDeleted = 15 [default = false];
}


message ReplicationGroupUpdate {
    required string             id              = 1;
    required uint64             updateNumber    = 2;
    required UpdateType         updateType      = 3;
    required ReconfigStateType  rgStatus        = 4;
    repeated ZoneCosInfo        zoneCos         = 5;
    optional string             name            = 6;
    optional string             etag            = 7;
    optional int64              creationTime    = 8;
    optional string             etagFromRgInfo  = 9;
}

